<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>GP DrawItems Preview</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: #0a0a0a; color: #ccc; font-family: monospace; display: flex; height: 100vh; overflow: hidden; }

  /* SIDEBAR */
  #sidebar {
    width: 240px; min-width: 240px; background: #111; border-right: 1px solid #222;
    display: flex; flex-direction: column; overflow-y: auto;
  }
  #sidebar h2 { padding: 12px 12px 8px; color: #0f8; font-size: 12px; border-bottom: 1px solid #1e1e1e; letter-spacing: 1px; }
  .folder { padding: 6px 12px 2px; color: #666; font-size: 11px; letter-spacing: 1px; cursor: default; user-select: none; }
  .folder span { color: #444; margin-right: 4px; }
  .item {
    padding: 5px 12px 5px 24px; font-size: 11px; color: #888; cursor: pointer;
    border-left: 2px solid transparent; transition: all 0.1s;
  }
  .item:hover { color: #ccc; background: #161616; }
  .item.active { color: #0f8; border-left-color: #0f8; background: #0a1a0a; }

  /* MAIN */
  #main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

  /* TOOLBAR */
  #toolbar {
    background: #111; border-bottom: 1px solid #222; padding: 8px 16px;
    display: flex; align-items: center; gap: 16px; flex-wrap: wrap;
  }
  #toolbar h3 { color: #0f8; font-size: 12px; white-space: nowrap; }
  .ctrl { display: flex; align-items: center; gap: 6px; font-size: 11px; color: #666; }
  .ctrl label { white-space: nowrap; }
  .ctrl input[type=range] { width: 80px; accent-color: #0f8; }
  .ctrl span { color: #0f8; min-width: 28px; }
  #playBtn {
    padding: 4px 10px; background: #1a2a1a; border: 1px solid #0f8; color: #0f8;
    font-family: monospace; font-size: 11px; cursor: pointer; white-space: nowrap;
  }
  #playBtn:hover { background: #0f8; color: #000; }

  /* CANVAS AREA */
  #canvasWrap {
    flex: 1; display: flex; align-items: center; justify-content: center;
    background: #0a0a0a; position: relative;
  }
  canvas { image-rendering: pixelated; }

  /* INFO BAR */
  #info {
    background: #111; border-top: 1px solid #222; padding: 6px 16px;
    font-size: 10px; color: #444; display: flex; gap: 24px;
  }
  #info span { color: #555; }
  #info b { color: #0a8; }

  /* DESC */
  #desc {
    background: #0d0d0d; border-bottom: 1px solid #1a1a1a;
    padding: 6px 16px; font-size: 10px; color: #556; font-style: italic; min-height: 24px;
  }

  /* COPY BOX */
  #copyBox {
    background: #111; border-top: 1px solid #1a1a1a; padding: 6px 16px;
    font-size: 10px; color: #0a8; white-space: pre; min-height: 22px;
  }
</style>
</head>
<body>

<div id="sidebar">
  <h2>üìÅ DRAW ITEMS</h2>

  <div class="folder"><span>‚ñæ</span>SSHcrack_v2</div>
  <div class="item active" data-item="ssh_vanilla">vanilla_clone.js</div>
  <div class="item" data-item="ssh_column">column_sweep.js</div>
  <div class="item" data-item="ssh_waveform">waveform.js</div>

  <div class="folder"><span>‚ñæ</span>FTPBounce_v2</div>
  <div class="item" data-item="ftp_vanilla">vanilla_clone.js</div>
  <div class="item" data-item="ftp_packets">packet_rows.js</div>
  <div class="item" data-item="ftp_stream">bounce_stream.js</div>

  <div class="folder"><span>‚ñæ</span>WebServerWorm_v2</div>
  <div class="item" data-item="web_vanilla">vanilla_clone.js</div>
  <div class="item" data-item="web_headers">http_headers.js</div>
  <div class="item" data-item="web_spiral">spiral_unlock.js</div>
</div>

<div id="main">
  <div id="toolbar">
    <h3 id="itemTitle">SSHcrack_v2 / vanilla_clone</h3>
    <div class="ctrl">
      <label>Progress</label>
      <input type="range" id="pctSlider" min="0" max="100" value="45">
      <span id="pctVal">45%</span>
    </div>
    <div class="ctrl">
      <label>HeaderH</label>
      <input type="range" id="headerH" min="16" max="48" value="28">
      <span id="headerHVal">28</span>
    </div>
    <div class="ctrl">
      <label>CharW</label>
      <input type="range" id="charW" min="4" max="14" value="6">
      <span id="charWVal">6</span>
    </div>
    <div class="ctrl">
      <label>CharH</label>
      <input type="range" id="charH" min="6" max="18" value="11">
      <span id="charHVal">11</span>
    </div>
    <button id="playBtn">‚ñ∂ PLAY</button>
  </div>
  <div id="desc">Select an item from the sidebar to preview.</div>
  <div id="canvasWrap">
    <canvas id="c" width="220" height="130"></canvas>
  </div>
  <div id="copyBox">// select a draw item</div>
  <div id="info">
    <span>grid <b id="gridInfo">?√ó?</b></span>
    <span>panel <b>220√ó130</b></span>
    <span>font <b id="fontInfo">6√ó11</b></span>
    <span>variant <b id="variantName">-</b></span>
  </div>
</div>

<script>
// ============================================================
// CONSTANTS
// ============================================================
const HEX = '0123456789ABCDEF'.split('');
const PANEL_W = 220, PANEL_H = 130;

// Per-exe accent colors (cracked state)
const COLORS = {
  ssh: { r:200, g:120, b:0,   name:'SSH V2',  port:'10022', label:'SSHcrack_v2'   },
  ftp: { r:0,   g:140, b:220, name:'FTP V2',  port:'10021', label:'FTPBounce_v2'  },
  web: { r:160, g:0,   b:220, name:'WEB V2',  port:'10080', label:'WebServerWorm_v2' },
};
const UNCRACKED = { r:180, g:0,   b:0 };

function toRgb(c, a=1) { return `rgba(${c.r},${c.g},${c.b},${a})`; }
function rnd(arr) { return arr[Math.floor(Math.random()*arr.length)]; }
function rndHex() { return rnd(HEX); }

// ============================================================
// STATE
// ============================================================
let params = { pct:0.45, headerH:28, charW:6, charH:11 };
let playing = false;
let playPct = 0;
let raf = null;
let lastT = null;
let flickerTimer = 0;
let currentRenderer = null;
let rendererState = {};

// ============================================================
// DRAW ITEMS REGISTRY
// ============================================================
const ITEMS = {};

// ------ HELPERS for all renderers ------
function initGrid(cols, rows) {
  const grid = [], threshold = [], order = [];
  for (let r=0; r<rows; r++) {
    grid.push([]); threshold.push([]);
    for (let c=0; c<cols; c++) {
      grid[r].push(rndHex());
      threshold[r].push(Math.random());
      order.push([r,c]);
    }
  }
  // shuffle order for random-unlock patterns
  order.sort(() => Math.random()-0.5);
  return { grid, threshold, order };
}

function drawHeader(ctx, label, port, accent) {
  const h = params.headerH;
  ctx.fillStyle = '#12121e';
  ctx.fillRect(0, 0, PANEL_W, h);
  ctx.fillStyle = toRgb(accent, 0.7);
  ctx.fillRect(0, h-2, PANEL_W, 2);
  ctx.font = `${Math.max(9, params.charH-2)}px monospace`;
  ctx.fillStyle = '#999';
  ctx.fillText(label, 6, h-7);
  ctx.fillStyle = toRgb(accent);
  ctx.fillText(port, PANEL_W - 50, h-7);
}

function drawOutline(ctx, accent) {
  ctx.strokeStyle = toRgb(accent, 0.4);
  ctx.lineWidth = 1;
  ctx.strokeRect(0.5, 0.5, PANEL_W-1, PANEL_H-1);
}

function clearContent(ctx) {
  ctx.fillStyle = '#080808';
  ctx.fillRect(0, params.headerH, PANEL_W, PANEL_H - params.headerH);
}

// ============================================================
// SSH vanilla_clone ‚Äî random threshold grid, same as vanilla
// ============================================================
ITEMS['ssh_vanilla'] = {
  exe: 'ssh', name: 'vanilla_clone',
  desc: 'Faithful recreation of vanilla SSHcrack.exe ‚Äî random threshold grid, red‚Üíorange flip.',
  init(cols, rows) {
    rendererState = initGrid(cols, rows);
  },
  tick(dt, cols, rows) {
    flickerTimer += dt;
    if (flickerTimer >= 0.08) {
      flickerTimer = 0;
      const { grid, threshold } = rendererState;
      for (let r=0; r<rows; r++)
        for (let c=0; c<cols; c++)
          if (threshold[r][c] > params.pct)
            grid[r][c] = rndHex();
    }
  },
  draw(ctx, cols, rows, accent) {
    const { grid, threshold } = rendererState;
    const cX = 4, cY = params.headerH, cW = params.charW, cH = params.charH;
    ctx.font = `${cH-1}px monospace`;
    for (let r=0; r<rows; r++) {
      for (let c=0; c<cols; c++) {
        ctx.fillStyle = threshold[r][c] <= params.pct ? toRgb(accent) : toRgb(UNCRACKED);
        ctx.fillText(grid[r][c], cX + c*cW, cY + r*cH + cH - 2);
      }
    }
  }
};

// ============================================================
// SSH column_sweep ‚Äî columns unlock left to right
// ============================================================
ITEMS['ssh_column'] = {
  exe: 'ssh', name: 'column_sweep',
  desc: 'Columns unlock sequentially left to right. Uncracked columns flicker independently.',
  init(cols, rows) {
    rendererState = initGrid(cols, rows);
    rendererState.colFlicker = Array.from({length:cols}, () => 0);
  },
  tick(dt, cols, rows) {
    flickerTimer += dt;
    if (flickerTimer >= 0.08) {
      flickerTimer = 0;
      const { grid } = rendererState;
      const crackedCols = Math.floor(params.pct * cols);
      for (let r=0; r<rows; r++)
        for (let c=crackedCols; c<cols; c++)
          grid[r][c] = rndHex();
    }
  },
  draw(ctx, cols, rows, accent) {
    const { grid } = rendererState;
    const cX = 4, cY = params.headerH, cW = params.charW, cH = params.charH;
    const crackedCols = Math.floor(params.pct * cols);
    ctx.font = `${cH-1}px monospace`;
    for (let r=0; r<rows; r++) {
      for (let c=0; c<cols; c++) {
        // leading edge gets bright flash
        const isEdge = c === crackedCols;
        if (c < crackedCols)      ctx.fillStyle = toRgb(accent);
        else if (isEdge)           ctx.fillStyle = 'rgba(255,255,255,0.9)';
        else                       ctx.fillStyle = toRgb(UNCRACKED);
        ctx.fillText(grid[r][c], cX + c*cW, cY + r*cH + cH - 2);
      }
    }
  }
};

// ============================================================
// SSH waveform ‚Äî sine wave of cracked chars sweeps through
// ============================================================
ITEMS['ssh_waveform'] = {
  exe: 'ssh', name: 'waveform',
  desc: 'A sine wave of cracked chars sweeps through the grid. Looks like signal interference.',
  init(cols, rows) {
    rendererState = initGrid(cols, rows);
    rendererState.wave = 0;
  },
  tick(dt, cols, rows) {
    rendererState.wave += dt * 3;
    flickerTimer += dt;
    if (flickerTimer >= 0.08) {
      flickerTimer = 0;
      const { grid, threshold } = rendererState;
      for (let r=0; r<rows; r++)
        for (let c=0; c<cols; c++)
          if (threshold[r][c] > params.pct)
            grid[r][c] = rndHex();
    }
  },
  draw(ctx, cols, rows, accent) {
    const { grid, threshold, wave } = rendererState;
    const cX = 4, cY = params.headerH, cW = params.charW, cH = params.charH;
    ctx.font = `${cH-1}px monospace`;
    for (let r=0; r<rows; r++) {
      for (let c=0; c<cols; c++) {
        const base = threshold[r][c] <= params.pct;
        // wave offset adds a shimmer band
        const waveVal = Math.sin(wave + c*0.6 + r*0.3);
        const shimmer = waveVal > 0.7 && !base;
        if (base)         ctx.fillStyle = toRgb(accent);
        else if (shimmer) ctx.fillStyle = toRgb({r:220,g:180,b:80}, 0.8);
        else              ctx.fillStyle = toRgb(UNCRACKED);
        ctx.fillText(grid[r][c], cX + c*cW, cY + r*cH + cH - 2);
      }
    }
  }
};

// ============================================================
// FTP vanilla_clone ‚Äî same logic, FTP blue accent
// ============================================================
ITEMS['ftp_vanilla'] = {
  exe: 'ftp', name: 'vanilla_clone',
  desc: 'Vanilla-style hex grid with FTP blue accent. Identical behavior to SSH vanilla_clone.',
  init(cols, rows) { rendererState = initGrid(cols, rows); },
  tick(dt, cols, rows) {
    flickerTimer += dt;
    if (flickerTimer >= 0.08) {
      flickerTimer = 0;
      const { grid, threshold } = rendererState;
      for (let r=0; r<rows; r++)
        for (let c=0; c<cols; c++)
          if (threshold[r][c] > params.pct) grid[r][c] = rndHex();
    }
  },
  draw(ctx, cols, rows, accent) {
    const { grid, threshold } = rendererState;
    const cX = 4, cY = params.headerH, cW = params.charW, cH = params.charH;
    ctx.font = `${cH-1}px monospace`;
    for (let r=0; r<rows; r++)
      for (let c=0; c<cols; c++) {
        ctx.fillStyle = threshold[r][c] <= params.pct ? toRgb(accent) : toRgb(UNCRACKED);
        ctx.fillText(grid[r][c], cX + c*cW, cY + r*cH + cH - 2);
      }
  }
};

// ============================================================
// FTP packet_rows ‚Äî each row is a packet, completes independently
// ============================================================
ITEMS['ftp_packets'] = {
  exe: 'ftp', name: 'packet_rows',
  desc: 'Each row is a data packet. Rows complete in order as overall progress advances.',
  init(cols, rows) {
    rendererState = initGrid(cols, rows);
    rendererState.rowProgress = new Array(rows).fill(0);
  },
  tick(dt, cols, rows) {
    flickerTimer += dt;
    if (flickerTimer >= 0.08) {
      flickerTimer = 0;
      const { grid } = rendererState;
      for (let r=0; r<rows; r++)
        for (let c=0; c<cols; c++)
          if (grid[r][c] !== '‚ñ†') grid[r][c] = rndHex();
    }
  },
  draw(ctx, cols, rows, accent) {
    const { grid } = rendererState;
    const cX = 4, cY = params.headerH, cW = params.charW, cH = params.charH;
    ctx.font = `${cH-1}px monospace`;
    const crackedRows = Math.floor(params.pct * rows);
    for (let r=0; r<rows; r++) {
      const crackedCols = r < crackedRows ? cols : (r === crackedRows ? Math.floor(params.pct * cols * rows % cols) : 0);
      for (let c=0; c<cols; c++) {
        if (c < crackedCols)    ctx.fillStyle = toRgb(accent);
        else if (c===crackedCols && r===crackedRows) ctx.fillStyle = 'rgba(255,255,255,0.9)';
        else                     ctx.fillStyle = toRgb(UNCRACKED, 0.7);
        ctx.fillText(grid[r][c], cX + c*cW, cY + r*cH + cH - 2);
      }
    }
  }
};

// ============================================================
// FTP bounce_stream ‚Äî chars stream in from right
// ============================================================
ITEMS['ftp_stream'] = {
  exe: 'ftp', name: 'bounce_stream',
  desc: 'Characters stream in from the right edge. Cracked region grows rightward with FTP protocol feel.',
  init(cols, rows) {
    rendererState = initGrid(cols, rows);
    rendererState.streamOffset = 0;
  },
  tick(dt, cols, rows) {
    rendererState.streamOffset = (rendererState.streamOffset + dt * 8) % 1;
    flickerTimer += dt;
    if (flickerTimer >= 0.08) {
      flickerTimer = 0;
      const { grid, threshold } = rendererState;
      for (let r=0; r<rows; r++)
        for (let c=0; c<cols; c++)
          if (threshold[r][c] > params.pct) grid[r][c] = rndHex();
    }
  },
  draw(ctx, cols, rows, accent) {
    const { grid, threshold, streamOffset } = rendererState;
    const cX = 4, cY = params.headerH, cW = params.charW, cH = params.charH;
    ctx.font = `${cH-1}px monospace`;
    for (let r=0; r<rows; r++) {
      for (let c=0; c<cols; c++) {
        const cracked = threshold[r][c] <= params.pct;
        // trailing glow effect near crack boundary
        const nearEdge = Math.abs(threshold[r][c] - params.pct) < 0.08;
        const streamPulse = Math.sin((c / cols + streamOffset) * Math.PI * 4) * 0.5 + 0.5;
        if (cracked)          ctx.fillStyle = toRgb(accent, 0.7 + 0.3 * streamPulse);
        else if (nearEdge)    ctx.fillStyle = toRgb({r:100,g:180,b:255}, 0.9);
        else                  ctx.fillStyle = toRgb(UNCRACKED, 0.5 + 0.5 * (1 - streamPulse * 0.3));
        ctx.fillText(grid[r][c], cX + c*cW, cY + r*cH + cH - 2);
      }
    }
  }
};

// ============================================================
// WEB vanilla_clone ‚Äî same logic, purple accent
// ============================================================
ITEMS['web_vanilla'] = {
  exe: 'web', name: 'vanilla_clone',
  desc: 'Vanilla-style hex grid with WebServerWorm purple accent.',
  init(cols, rows) { rendererState = initGrid(cols, rows); },
  tick(dt, cols, rows) {
    flickerTimer += dt;
    if (flickerTimer >= 0.08) {
      flickerTimer = 0;
      const { grid, threshold } = rendererState;
      for (let r=0; r<rows; r++)
        for (let c=0; c<cols; c++)
          if (threshold[r][c] > params.pct) grid[r][c] = rndHex();
    }
  },
  draw(ctx, cols, rows, accent) {
    const { grid, threshold } = rendererState;
    const cX = 4, cY = params.headerH, cW = params.charW, cH = params.charH;
    ctx.font = `${cH-1}px monospace`;
    for (let r=0; r<rows; r++)
      for (let c=0; c<cols; c++) {
        ctx.fillStyle = threshold[r][c] <= params.pct ? toRgb(accent) : toRgb(UNCRACKED);
        ctx.fillText(grid[r][c], cX + c*cW, cY + r*cH + cH - 2);
      }
  }
};

// ============================================================
// WEB http_headers ‚Äî scrolling HTTP-like headers
// ============================================================
ITEMS['web_headers'] = {
  exe: 'web', name: 'http_headers',
  desc: 'Renders fake HTTP request/response headers. Each header "sends" as progress advances.',
  init(cols, rows) {
    const headers = [
      'GET / HTTP/1.1',
      'Host: target.node',
      'X-GP-Crack: v2',
      'X-Tier: 2',
      'X-Port: 10080',
      'Exploit: overflow',
      'Payload: 0x' + Math.floor(Math.random()*0xFFFF).toString(16).toUpperCase(),
      'Cookie: sess=inject',
      'Pragma: no-cache',
      'Connection: exploit',
      '---',
      'HTTP/1.1 200 OK',
      'Server: exploited',
      'Port: OPEN',
    ];
    rendererState = { headers, scrollY: 0 };
  },
  tick(dt, cols, rows) {
    rendererState.scrollY += dt * 14 * params.pct;
  },
  draw(ctx, cols, rows, accent) {
    const { headers, scrollY } = rendererState;
    const cY = params.headerH + 4, cH = params.charH;
    const visibleRows = rows;
    const totalLines = headers.length;
    const crackedLines = Math.floor(params.pct * totalLines);
    ctx.font = `${cH-1}px monospace`;
    for (let i=0; i<visibleRows; i++) {
      const lineIdx = Math.floor(scrollY / cH + i) % totalLines;
      const line = headers[lineIdx] || '';
      const iscracked = lineIdx < crackedLines;
      const isCurrent = lineIdx === crackedLines;
      if (isCurrent)       ctx.fillStyle = 'rgba(255,255,180,0.9)';
      else if (iscracked)  ctx.fillStyle = toRgb(accent, 0.9);
      else                 ctx.fillStyle = toRgb(UNCRACKED, 0.6);
      ctx.fillText(line.substring(0, Math.floor(PANEL_W / params.charW)), 6, cY + i * cH + cH - 2);
    }
  }
};

// ============================================================
// WEB spiral_unlock ‚Äî chars unlock in spiral from center
// ============================================================
ITEMS['web_spiral'] = {
  exe: 'web', name: 'spiral_unlock',
  desc: 'Chars unlock in a spiral pattern from the center outward. Unusual, high-visibility.',
  init(cols, rows) {
    rendererState = initGrid(cols, rows);
    // Build spiral order
    const order = [];
    let top=0, bottom=rows-1, left=0, right=cols-1;
    // spiral from outside in and reverse for center-out
    while (top<=bottom && left<=right) {
      for (let c=left; c<=right; c++) order.push([top,c]);
      top++;
      for (let r=top; r<=bottom; r++) order.push([r,right]);
      right--;
      if (top<=bottom) { for (let c=right; c>=left; c--) order.push([bottom,c]); bottom--; }
      if (left<=right) { for (let r=bottom; r>=top; r--) order.push([r,left]); left++; }
    }
    order.reverse(); // center-out
    rendererState.spiralOrder = order;
  },
  tick(dt, cols, rows) {
    flickerTimer += dt;
    if (flickerTimer >= 0.08) {
      flickerTimer = 0;
      const { grid, spiralOrder } = rendererState;
      const crackedCount = Math.floor(params.pct * spiralOrder.length);
      spiralOrder.slice(crackedCount).forEach(([r,c]) => {
        grid[r][c] = rndHex();
      });
    }
  },
  draw(ctx, cols, rows, accent) {
    const { grid, spiralOrder } = rendererState;
    const cX = 4, cY = params.headerH, cW = params.charW, cH = params.charH;
    const crackedCount = Math.floor(params.pct * spiralOrder.length);
    // Build set of cracked positions
    const crackedSet = new Set();
    for (let i=0; i<crackedCount; i++) {
      const [r,c] = spiralOrder[i];
      crackedSet.add(r*1000+c);
    }
    ctx.font = `${cH-1}px monospace`;
    for (let r=0; r<rows; r++) {
      for (let c=0; c<cols; c++) {
        ctx.fillStyle = crackedSet.has(r*1000+c) ? toRgb(accent) : toRgb(UNCRACKED);
        ctx.fillText(grid[r][c], cX + c*cW, cY + r*cH + cH - 2);
      }
    }
  }
};

// ============================================================
// ENGINE
// ============================================================
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let activeKey = 'ssh_vanilla';
let cols = 0, rows = 0;

function getColsRows() {
  const cW = PANEL_W - 8;
  const cH = PANEL_H - params.headerH - 4;
  return [
    Math.max(1, Math.floor(cW / params.charW)),
    Math.max(1, Math.floor(cH / params.charH))
  ];
}

function loadItem(key) {
  activeKey = key;
  [cols, rows] = getColsRows();
  rendererState = {};
  flickerTimer = 0;
  const item = ITEMS[key];
  item.init(cols, rows);

  // UI
  document.querySelectorAll('.item').forEach(el => el.classList.remove('active'));
  document.querySelector(`[data-item="${key}"]`).classList.add('active');
  const ex = COLORS[item.exe];
  document.getElementById('itemTitle').textContent = `${ex.label} / ${item.name}`;
  document.getElementById('variantName').textContent = item.name;
  document.getElementById('desc').textContent = item.desc;
  document.getElementById('gridInfo').textContent = `${cols}√ó${rows}`;
  document.getElementById('fontInfo').textContent = `${params.charW}√ó${params.charH}`;
  updateCopyBox();
}

function updateCopyBox() {
  document.getElementById('copyBox').textContent =
    `public static int HeaderH = ${params.headerH};  // DrawTestParams\n` +
    `public static int CharW   = ${params.charW};\n` +
    `public static int CharH   = ${params.charH};`;
}

function frame(ts) {
  if (!lastT) lastT = ts;
  const dt = Math.min((ts - lastT) / 1000, 0.1);
  lastT = ts;

  if (playing) {
    playPct = Math.min(playPct + dt * 0.08, 1);
    params.pct = playPct;
    document.getElementById('pctSlider').value = Math.round(playPct * 100);
    document.getElementById('pctVal').textContent = Math.round(playPct * 100) + '%';
    if (playPct >= 1) { playing = false; document.getElementById('playBtn').textContent = '‚ñ∂ PLAY'; playPct = 0; }
  }

  [cols, rows] = getColsRows();

  const item = ITEMS[activeKey];
  item.tick(dt, cols, rows);

  // Draw
  ctx.fillStyle = '#080808';
  ctx.fillRect(0, 0, PANEL_W, PANEL_H);

  const accent = COLORS[item.exe];
  clearContent(ctx);
  item.draw(ctx, cols, rows, accent);
  drawHeader(ctx, accent.label, accent.port, accent);
  drawOutline(ctx, accent);

  raf = requestAnimationFrame(frame);
}

// ============================================================
// CONTROLS
// ============================================================
document.querySelectorAll('.item').forEach(el => {
  el.addEventListener('click', () => loadItem(el.dataset.item));
});

const sliders = [
  ['pctSlider',  'pctVal',    v => { params.pct = v/100; return Math.round(v)+'%'; }],
  ['headerH',    'headerHVal',v => { params.headerH = v; loadItem(activeKey); return v; }],
  ['charW',      'charWVal',  v => { params.charW = v;   loadItem(activeKey); return v; }],
  ['charH',      'charHVal',  v => { params.charH = v;   loadItem(activeKey); return v; }],
];
sliders.forEach(([id, valId, fn]) => {
  const el = document.getElementById(id);
  el.addEventListener('input', () => {
    const v = parseInt(el.value);
    document.getElementById(valId).textContent = fn(v);
    document.getElementById('gridInfo').textContent = `${getColsRows()[0]}√ó${getColsRows()[1]}`;
    document.getElementById('fontInfo').textContent = `${params.charW}√ó${params.charH}`;
    updateCopyBox();
  });
});

document.getElementById('playBtn').addEventListener('click', () => {
  if (playing) {
    playing = false;
    document.getElementById('playBtn').textContent = '‚ñ∂ PLAY';
  } else {
    playing = true;
    playPct = 0;
    params.pct = 0;
    document.getElementById('pctSlider').value = 0;
    document.getElementById('pctVal').textContent = '0%';
    document.getElementById('playBtn').textContent = '‚èπ STOP';
  }
});

// ============================================================
// BOOT
// ============================================================
loadItem('ssh_vanilla');
raf = requestAnimationFrame(frame);
</script>
</body>
</html>
